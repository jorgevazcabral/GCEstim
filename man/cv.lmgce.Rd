% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv.lmgce.R
\name{cv.lmgce}
\alias{cv.lmgce}
\title{Cross-validation for \code{\link{lmgce}}}
\usage{
cv.lmgce(
  formula,
  data,
  subset,
  na.action,
  offset,
  contrasts = NULL,
  model = TRUE,
  x = FALSE,
  y = FALSE,
  cv = TRUE,
  cv.nfolds = 5,
  errormeasure = c("RMSE", "MSE", "MAE", "MAPE", "sMAPE", "MASE"),
  errormeasure.which = {
     if (isTRUE(cv)) 
         c("1se", "min", "elbow")
    
    else c("min", "elbow")
 },
  support.method = c("standardized", "ridge"),
  support.method.ridge.lambda = NULL,
  support.method.ridge.base = 10,
  support.method.ridge.lambda.min = 10^-3,
  support.method.ridge.lambda.max = 10^3,
  support.method.ridge.lambda.n = 100,
  support.method.ridge.standardize = TRUE,
  support.method.ridge.penalize.intercept = TRUE,
  support.method.ridge.symm = TRUE,
  support.method.ridge.maxresid = TRUE,
  support.signal = NULL,
  support.signal.vector = NULL,
  support.signal.vector.min = 0.3,
  support.signal.vector.max = 20,
  support.signal.vector.n = 20,
  support.signal.points = c(3, 5, 7, 9),
  support.noise = NULL,
  support.noise.points = c(3, 5, 7, 9),
  weight = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9),
  twosteps.n = 1,
  method = c("dual.lbfgsb3c", "dual.BFGS", "dual", "primal.solnl", "primal.solnp",
    "dual.CG", "dual.L-BFGS-B", "dual.Rcgmin", "dual.bobyqa", "dual.newuoa",
    "dual.nlminb", "dual.nlm", "dual.lbfgs", "dual.optimParallel"),
  caseGLM = c("D", "M", "NM"),
  boot.B = 0,
  boot.method = c("residuals", "cases", "wild"),
  seed = 230676,
  OLS = TRUE,
  verbose = 0,
  coef = NULL
)
}
\arguments{
\item{formula}{An object of class \code{\link[stats]{formula}} (or one that
can be coerced to that class): a symbolic description of the model to be
fitted.}

\item{data}{A data frame (or object coercible by
\code{\link[base]{as.data.frame}} to a data frame) containing the variables
 in the model.}

\item{subset}{an optional vector specifying a subset of observations to be
used in the fitting process.}

\item{na.action}{a function which indicates what should happen when the data
contain \code{NA}s. The default is set by the \code{na.action} setting of
\code{\link[base]{options}}, and is \code{\link[stats]{na.fail}} if that is
unset. The ‘factory-fresh’ default is \code{\link[stats]{na.omit}}. Another
possible value is \code{NULL}, no action. Value
 \code{\link[stats]{na.exclude}} can be useful.}

\item{offset}{this can be used to specify an a priori known component to be
included in the linear predictor during fitting. This should be \code{NULL}
or a numeric vector or matrix of extents matching those of the response. One
or more \code{\link[stats]{offset}} terms can be included in the formula
instead or as well, and if more than one are specified their sum is used.
See \code{\link[stats]{model.offset}}.}

\item{contrasts}{An optional list. See the \code{contrasts.arg} of
\code{\link[stats]{model.matrix.default}}.}

\item{model}{Boolean value. if \code{TRUE}, the model frame used is returned.
The default is \code{model = TRUE}.}

\item{x}{Boolean value. if \code{TRUE}, the model matrix used is returned.
The default is \code{x = FALSE}.}

\item{y}{Boolean value. if \code{TRUE}, the response used is returned.
The default is \code{y = FALSE}.}

\item{cv}{Boolean value. If \code{TRUE} the error, \code{errormeasure},
will be computed using cross-validation. If \code{FALSE} the error will be
computed in sample. The default is \code{cv = TRUE}.}

\item{cv.nfolds}{number of folds used for cross-validation when
\code{cv = TRUE}. The default is \code{cv.nfolds = 5} and the smallest value
allowable is \code{cv.nfolds = 3}.}

\item{errormeasure}{Loss function (error) to be used for the selection
of the support spaces. One of c("RMSE","MSE", "MAE", "MAPE", "sMAPE", "MASE").
The default is \code{errormeasure = "RMSE"}.}

\item{errormeasure.which}{Which value of \code{errormeasure}
to be used for selecting a support space upper limit from \code{support.signal.vector}.
One of \code{c("min", "1se", "elbow")} where \code{"min"} corresponds to the
support spaces that produced the lowest error, \code{"1se"} corresponds to
the support spaces such that error is within 1 standard error of the CV error
for \code{"min"} and \code{"elbow"} corresponds to the elbow point of the error
curve (the point that maximizes the distance between each observation, i.e,
the pair composed by the upper limit of the support space and the error, and
the line between the first and last observations, i.e., the lowest and the
highest upper limits of the support space respectively. See
\code{\link[pathviewr]{find_curve_elbow}}). The default is
\code{errormeasure.which = "1se"}.}

\item{support.method}{One of c("standardized", "ridge"). If
\code{support.method = "standardized}, the default, standardized coefficients
are used to define the signal support spaces. If
\code{support.method = "ridge} the signal support spaces are define by the
ridge trace.}

\item{support.method.ridge.lambda}{Ridge parameter. The default is
\code{support.method.ridge.lambda = NULL} and a lambda base
\code{support.method.ridge.base} logarithmic sequence will be computed based
on \code{support.method.ridge.lambda.n}, \code{support.method.ridge.lambda.min}
 and \code{support.method.ridge.lambda.max}. Supplying a lambda sequence
overrides this. To be used when \code{support.method = "ridge"}.}

\item{support.method.ridge.lambda.min}{Minimum value for the
\code{support.method.ridge.lambda} sequence. The default is
\code{support.method.ridge.lambda.min = 10^-3}. To be used when
\code{support.method = "ridge"} and \code{support.method.ridge.lambda = NULL}.}

\item{support.method.ridge.lambda.max}{Maximum value for the
\code{support.method.ridge.lambda} sequence. The default is
\code{support.method.ridge.lambda.max = 10^3}. To be used when
\code{support.method = "ridge"} and \code{support.method.ridge.lambda = NULL}.}

\item{support.method.ridge.lambda.n}{The number of ridge parameters values.
The default is \code{support.method.ridge.lambda.n = 100}. To be used when
 \code{support.method = "ridge"} and \code{support.method.ridge.lambda = NULL}.}

\item{support.method.ridge.standardize}{Boolean value. If \code{TRUE}, the
default, then: i) centering is done by subtracting the column means of x and
y from their corresponding columns; ii) scaling is done by dividing the
(centered) columns of x and y by their standard deviations. To be used when
\code{support.method = "ridge"}.}

\item{support.method.ridge.penalize.intercept}{Boolean value. if \code{TRUE},
the default, the intercept will be penalized. To be used when
\code{support.method = "ridge"} and
\code{support.method.ridge.standardize = FALSE}.}

\item{support.method.ridge.symm}{Boolean value. If \code{TRUE}, the default,
signal supports will be symmetrical and the upper limit will be the maximum
 absolute values of the estimated ridge coefficients for
 \code{support.method.ridge.lambda}. If \code{FALSE}, the lower and upper
 limits will be, respectively, the minimum and maximum values of the
 estimated ridge coefficients.}

\item{support.method.ridge.maxresid}{Boolean value. if \code{TRUE}, the
default, noise supports will symmetrical and the upper limit will be the
maximum absolute value of the residuals of ridge estimation for
 \code{support.method.ridge.lambda}. If \code{FALSE} limits are computed
 using the empirical three-sigma rule (Pukelsheim (1994)).}

\item{support.signal}{\code{NULL} or fixed positive upper limit (L) for the
support spaces (-L,L) on standardized data (when
\code{support.method = "standardized"}); \code{NULL} or fixed positive factor
 to be multiplied by the maximum absolute value of the ridge trace for each
 coefficient (when \code{support.method = "ridge"}); a pair (LL,UL) or a
 matrix ((k+1) x 2) for the support spaces on original data. The default is
 \code{support.signal = NULL}.}

\item{support.signal.vector}{NULL or a vector of positive values when
\code{support.signal = NULL}. If \code{support.signal.vector = NULL},
the default, a vector
\code{c(support.signal.vector.min,...,support.signal.vector.max)} of dimension
 \code{support.signal.vector.n} and logarithmically equally spaced will be
generated. Each value represents the upper limits for the standardized support
 spaces, when \code{support.method = "standardized"} or the factor to be
 multiplied by the maximum absolute value of the ridge trace for each
 coefficient, when \code{support.method = "ridge"}.}

\item{support.signal.vector.min}{A positive value for the lowest limit of the
\code{support.signal.vector} when \code{support.signal = NULL} and
\code{support.signal.vector = NULL}. The default is
\code{support.signal.vector.min = 0.3}.}

\item{support.signal.vector.max}{A positive value for the highest limit of the
\code{support.signal.vector} when \code{support.signal = NULL} and
\code{support.signal.vector = NULL}. The default is
\code{support.signal.vector.max = 20}.}

\item{support.signal.vector.n}{A positive integer for the number of support
spaces to be used when \code{support.signal = NULL} and
\code{support.signal.vector = NULL}. The default is
\code{support.signal.vector.n = 20}.}

\item{support.signal.points}{A vector of positive integers defining the number
 of points for the signal support to be tested .The default is
\code{support.signal.points = c(3, 5, 7, 9)}.}

\item{support.noise}{An interval, preferably centered around zero, given in the form
\code{c(LL,UL)}. If \code{support.noise = NULL}, the default, then a vector
\code{c(-L,L)} is computed using the empirical three-sigma rule
Pukelsheim (1994).}

\item{support.noise.points}{A vector of positive integers defining the number
 of points for the noise support to be tested .The default is
\code{support.noise.points = c(3, 5, 7, 9)}.}

\item{weight}{a vector of values between zero and one representing the
prediction-precision loss trade-off. The default is
\code{weight = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)}.}

\item{twosteps.n}{Number of GCE reestimations using a previously estimated
vector of signal probabilities.}

\item{method}{Use \code{"primal.solnl"} (GCE using Sequential Quadratic
Programming (SQP) method; see \code{\link[NlcOptim]{solnl}}) or
\code{"primal.solnp"} (GCE using the augmented Lagrange multiplier method
with an SQP interior algorithm; see \code{\link[Rsolnp]{solnp}}) for primal
form of the optimization problem and \code{"dual"} (GME), \code{"dual.CG"}
(GCE using a conjugate gradients method; see \code{\link[stats]{optim}}),
\code{"dual.BFGS"} (GCE using Broyden-Fletcher-Goldfarb-Shanno quasi-Newton
method; see \code{\link[stats]{optim}}), \code{"dual.L-BFGS-B"} (GCE using a
box-constrained optimization with limited-memory modification of the BFGS
quasi-Newton method; see \code{\link[stats]{optim}}), \code{dual.Rcgmin}
(GCE using an update of the conjugate gradient algorithm; see
\code{\link[optimx]{optimx}}),
\code{dual.bobyqa} (GCE using a derivative-free optimization by quadratic
approximation; see \code{\link[optimx]{optimx}} and
\code{\link[minqa]{bobyqa}}), \code{dual.newuoa} (GCE using a
derivative-free optimization by quadratic approximation; see
\code{\link[optimx]{optimx}} and \code{\link[minqa]{newuoa}}),
\code{dual.nlminb} (GCE; see \code{\link[optimx]{optimx}} and
\code{\link[stats]{nlminb}}), \code{dual.nlm} (GCE; see
\code{\link[optimx]{optimx}} and \code{\link[stats]{nlm}}),
\code{dual.lbfgs} (GCE using the Limited-memory
Broyden-Fletcher-Goldfarb-Shanno; see \code{\link[lbfgs]{lbfgs}}),
\code{dual.lbfgsb3c} (GCE using L-BFSC-B implemented in Fortran code and with
an Rcpp interface; see \code{\link[lbfgsb3c]{lbfgsb3c}}) or
\code{dual.optimParallel} (GCE using parallel version of the L-BFGS-B; see
\code{\link[optimParallel]{optimParallel}}) for dual form. The
default is \code{method = "dual.BFGS"}.}

\item{caseGLM}{special cases of the generic general linear model. One of
\code{c("D", "M", "NM")}, where "D" stands for data, "M" for moment and
 "NM" for normed-moment The default is
\code{caseGLM = "D"}.}

\item{boot.B}{A single positive integer greater or equal to 10 for the number
of bootstrap replicates to be used for the computation of the bootstrap
confidence interval(s). Zero value will generate no replicate. The default
is \code{boot.B = 0}.}

\item{boot.method}{Method to be use for bootstrapping. One of
\code{c("residuals", "cases", "wild")} which corresponds to resampling on
residuals, on individual cases or on residuals multiplied by a N(0,1) variable,
respectively. The default is \code{boot.method = "residuals"}.}

\item{seed}{A single value, interpreted as an integer, for reproducibility
or \code{NULL} for randomness. The default is \code{seed = 230676}.}

\item{OLS}{Boolean value. if \code{TRUE}, the default, OLS estimation is
performed.}

\item{verbose}{An integer to control how verbose the output is. For a value
of 0 no messages or output are shown and for a value of 3 all messages
are shown. The default is \code{verbose = 0}.}

\item{coef}{A vector of the true coefficients, when available.}

\item{support.method.ridge.lambda.base}{Value for the base of logarithmic
sequence of ridge parameters. The default is
\code{support.method.ridge.lambda.base = 10}. To be used when
\code{support.method = "ridge"} and \code{support.method.ridge.lambda = NULL}.}
}
\value{
\code{cv.lmgce} returns an object of \code{\link[base]{class}} \code{cv.lmgce}.

 An object of \code{\link[base]{class}} \code{cv.lmgce} is a list containing at
 least the following components:

\item{results}{a \eqn{C \times 8} \code{data.frame}, where C is the number of
combinations of the arguments \code{support.signal.points},
\code{support.noise.points} and \code{weight}. Contains information about the
arguments, error, convergence of the optimization method and time of
computation.}
\item{best}{a \code{\link{lmgce}} object obtained with the combination of
arguments that produced the lowest cross-validation error.}
\item{support.signal.points}{a vector of the \code{support.signal.points}
tested.}
\item{support.signal.points.best}{the value of \code{support.signal.points}
that produced the lowest cross-validation error.}
\item{support.noise.points}{a vector of the \code{support.noise.points}
tested.}
\item{support.noise.points.best}{the value of \code{support.noise.points}
that produced the lowest cross-validation error.}
\item{weight}{a vector of the \code{weight} tested.}
\item{weight.best}{the value of \code{weight} that produced the lowest
cross-validation error.}
}
\description{
Performs k-fold cross-validation for some of the \code{\link{lmgce}}
parameters.
}
\details{
The \code{cv.lmgce} function fits several linear regression models via
 generalized cross according to the defined arguments. In particular,
 \code{support.signal.points}, \code{support.noise.points} and
 \code{weight} can be defined as vectors.
}
\examples{
\donttest{
res.cv.lmgce <-
  cv.lmgce(y ~ .,
           data = dataGCE)

res.cv.lmgce
}

}
\references{
Golan, A., Judge, G. G. and Miller, D. (1996)
\emph{Maximum entropy econometrics : robust estimation with limited data.}
Wiley.\cr
Golan, A. (2008).
\emph{Information and Entropy Econometrics — A Review and Synthesis.}
Foundations and Trends® in Econometrics, 2(1–2), 1–145.
\doi{10.1561/0800000004}\cr
Golan, A. (2017)
\emph{Foundations of Info-Metrics: Modeling, Inference, and Imperfect Information (Vol. 1).}
Oxford University Press.
\doi{10.1093/oso/9780199349524.001.0001}\cr
Pukelsheim, F. (1994)
\emph{The Three Sigma Rule.}
The American Statistician, 48(2), 88–91.
\doi{10.2307/2684253}
}
\seealso{
See the generic functions \code{\link{plot.cv.lmgce}},
\code{\link{print.cv.lmgce}} and \code{\link{coef.cv.lmgce}}.
}
\author{
Jorge Cabral, \email{jorgecabral@ua.pt}
}
